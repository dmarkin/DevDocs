http://angular-doc.herokuapp.com/ - angular.ru
See https://scotch.io/tutorials/build-an-etsy-clone-with-angular-and-stamplay-part-1like example
See https://www.sitepoint.com/real-time-status-update-app-angularjs-firebase/ example

ng-app
Для директивы ngApp можно указать дополнительный атрибут – имя модуля, который будет загружен при инициализации приложения.

ng-controller
Его задача — создавать модель и транслировать ее в view вместе с колбэками.
Контроллер не должен содержать никакой информации о правилах отображения данных (ссылок на DOM, или HTML-фрагментов)
$scope используется только внутри контроллеров.
Контроллер может использоваться как модель (as)

ng-view
Место во view, куда грузятся шаблоны при переходе по routes


В AngularJS процесс проверки изменений в модели называется циклом обработки событий $digest (или просто цикл $digest).
Название происходит от имени метода $digest, доступного в объектах контекста Scope.
Во время компоновки шаблона директивы создают так называемых наблюдателей ($watch)
Наблюдатели уведомляют директивы об изменения свойств, чтобы те в свою очередь вовремя обновили значения элементов в DOM.
Метод $digest вызывается внутри метода $apply и вычисляет все выражения, находящиеся под наблюдением,
зарегистрированные во всех scopes.

! Не стоит запускать digest, если вы уже находитесь в фазе digest – это приведёт к непредсказуемым последствиям.
Обычно $digest() не вызывается напрямую из контроллеров или директив. Нужно вызывать $apply() (обычно это делают изнутри директив), который сам уже вызовет $digest().
$apply(expr) - разбирает и вычисляет выражение, и выполняет цикл $digest по $rootScope

Браузеры имеют единственный поток выполнения, обслуживающий пользовательский интерфейс.
В браузерах существуют и другие потоки выполнения (например, отвечающие за выполнение сетевых операций),
но только один поток может отображать на экране элементы DOM, обрабатывать события DOM и выполнять код JavaScript.
Браузеры постоянно переключаются между контекстом выполнения JavaScript и контекстом отображения DOM.

Для определения изменений AngularJS использует простое сравнение состояний объектов (dirty checking) при помощи $scope.$watch.
Он сравнивает ранее сохраненную копию модели с новой, полученной после обработки одного из событий,
которые могут вызвать изменение модели:
1) события DOM (обработчики событий ng-click, ng-mouseover etc.),
2) обратные вызовы, производимые объектом XHR при получении ответов от сервера ($http, $resource),
3) события навигации,
4) срабатывание таймера ($timeout - можно избежать запуска цикла $digest, передав 3м аргументом false; $interval).

Список методов, вызывающих цикл $digest:
$eval(expression, locals) - разбор и немедленное выполнение выражения
$evalAsync(expression) - разбор и отложенное выполнение выражения
$$asyncQueue - асинхронная очередь задач, обрабатывается на каждом цикле digest
$$postDigest(fn) - выполняет fn после следующего цикла digest
$$postDigestQueue - зарегистрированные при помощи $$postDigest(fn) методы
Большинство директив фреймворка вызывают эти функции. Они вызывают наблюдателей, а наблюдатели обновляют интерфейс.

В пользовательских директивах процедура проверки изменений в модели должна запускаться явно вызовом функции scope.$apply(Fn).
Если точно известно, какие контексты будут затронуты изменениями в модели, вместо scope.$apply можно вызвать метод
scope.$digest самого верхнего затронутого контекста, который выполнит цикл $digest на ограниченном подмножестве контекстов,
и вычислит выражения, зарегистрированные только в этом контексте и в его дочерних контекстах.
Этот прием может существенно уменьшить количество вычисляемых выражений и тем самым ускорить выполнение цикла $digest.

Минификация
1) Добавление аннотаций зависимостей в массив
2) ngmin (https://github.com/btford/ngmin)

Предварительная загрузка шаблонов
1) $templateCache
    grunt-html2js (https://github.com/karlgoldstein/grunt- html2js).
2) Для мелких проектов:
    <script type="text/ng-template" id="page.html">
    [html block]
    </script>
Для оптимизации можно использовать комбинированую загрузку шаблонов в нужный момент

Если начальная страница в основном состоит из статического содержимого, с небольшим количеством динамических фрагментов,
перенесите теги <script> в самый конец страницы и используйте директиву ng-bind для сокрытия привязок, пока страница
будет загружаться и обрабатываться. В противном случае перенесите теги <script> в тег <head> и используйте директиву ng-cloak.
ng-cloak - скрывает элементы DOM во время предварительной загрузки и первичной обработки шаблона


Спецификация определения асинхронных модулей (Asynchronous Module Definition, AMD), получившая популярность благодаря Require.js
и другим похожим библиотекам на JavaScript, описывает набор правил создания модулей многократного пользования,
которые могут загружаться асинхронно. Такие модули могут загружаться по требованию, с учетом всех зависимостей.
Не рекомендуется использовать асинхронные загрузчики (Require.js и аналогичные) в приложениях на основе Angular!


Оптимизация
! не нужно пихать в $scope то, что не нужно отображать прямо сейчас
https://makeomatic.ru/blog/2014/10/22/Optimizing_AngularJS/

Поддержка IE 8 и IE 7: http://docs.angularjs.org/guide/ie


http://davidcai.github.io/blog/posts/copy-vs-extend-vs-merge/
Копия: angular.copy is a deep copy.
Ссылка: angular.extend(dst, src1, src2, ...) is to shallow copy the properties of the source objects from right to left, all the way to the destination object.
или angular.merge is an Angular 1.4+ API that is to deep (recursively) copy the properties of the source objects to the destination object.

Watchers
$watch
$watchGroup - для массивов
$watchCollection - для массивов (hashes) и объектов

События Angular
$scope.$on('eventName', function () {}); - вешает обработчик (Listener) на событие eventName

<button ng-click="$emit('eventName')"></button> - отправляет событие eventName на всплытие
<button ng-click="$broadcast('eventName')"></button> - отправляет событие eventName на погружение

В реальной жизни события наиболее полезны, когда надо соединить несколько областей видимости.
Cобытия нужно использовать, когда вы ожидаете изменения Вида в ответ на событие, а сервисы – когда Виды не меняются.

Последовательная асинхронная инициализация Angular.JS приложений с использованием промисов
https://makeomatic.ru/blog/2014/04/04/Initialization_angularjs/

Некоторые свойства, которые начинаются с '$$' - являются приватными и не должны быть доступны как для чтения, так и для изменения

Create Memory Leaks at Angular app - https://makandracards.com/makandra/31289-how-to-create-giant-memory-leaks-in-angularjs