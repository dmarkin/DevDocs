В AngularJS процесс проверки изменений в модели называется циклом обработки событий $digest (или просто цикл $digest).
Название происходит от имени метода $digest, доступного в объектах контекста Scope.
Этот метод вызывается внутри метода $apply и вычисляет все выражения, находящиеся под наблюдением,
зарегистрированные во всех scopes.

Браузеры имеют единственный поток выполнения, обслуживающий пользовательский интерфейс.
В браузерах существуют и другие потоки выполнения (например, отвечающие за выполнение сетевых операций),
но только один поток может отображать на экране элементы DOM, обрабатывать события DOM и выполнять код JavaScript.
Браузеры постоянно переключаются между контекстом выполнения JavaScript и контекстом отображения DOM.

Для определения изменений AngularJS использует простое сравнение состояний объектов (dirty checking) при помощи $scope.$watch.
Он сравнивает ранее сохраненную копию модели с новой, полученной после обработки одного из событий,
которые могут вызвать изменение модели:
1) события DOM (обработчики событий ng-click, ng-mouseover etc.),
2) обратные вызовы, производимые объектом XHR при получении ответов от сервера ($http, $resource),
3) события навигации,
4) срабатывание таймера ($timeout - можно избежать запуска цикла $digest, передав 3м аргументом false; $interval).

В пользовательских директивах процедура проверки изменений в модели должна запускаться явно вызовом функции scope.$apply(Fn).
Если точно известно, какие контексты будут затронуты изменениями в модели, вместо scope.$apply можно вызвать метод
scope.$digest самого верхнего затронутого контекста, который выполнит цикл $digest на ограниченном подмножестве контекстов,
и вычислит выражения, зарегистрированные только в этом контексте и в его дочерних контекстах.
Этот прием может существенно уменьшить количество вычисляемых выражений и тем самым ускорить выполнение цикла $digest.

Минификация
1) Добавление аннотаций зависимостей в массив
2) ngmin (https://github.com/btford/ngmin)

Предварительная загрузка шаблонов
1) $templateCache
    grunt-html2js (https://github.com/karlgoldstein/grunt- html2js).
2) Для мелких проектов:
    <script type="text/ng-template" id="page.html">
    [html block]
    </script>
Для оптимизации можно использовать комбинированую загрузку шаблонов в нужный момент

Если начальная страница в основном состоит из статического содержимого, с небольшим количеством динамических фрагментов,
перенесите теги <script> в самый конец страницы и используйте директиву ng-bind для сокрытия привязок, пока страница
будет загружаться и обрабатываться. В противном случае перенесите теги <script> в тег <head> и используйте директиву ng-cloak.
ng-cloak - скрывает элементы DOM во время предварительной загрузки и первичной обработки шаблона


Спецификация определения асинхронных модулей (Asynchronous Module Definition, AMD), получившая популярность благодаря Require.js
и другим похожим библиотекам на JavaScript, описывает набор правил создания модулей многократного пользования,
которые могут загружаться асинхронно. Такие модули могут загружаться по требованию, с учетом всех зависимостей.
Не рекомендуется использовать асинхронные загрузчики (Require.js и аналогичные) в приложениях на основе Angular!


Оптимизация

В документации к фреймворку AngularJS имеется исчерпывающий раздел, описывающий все шаги,
необходимые для поддержки IE 8 и IE 7: http://docs.angularjs.org/guide/ie.