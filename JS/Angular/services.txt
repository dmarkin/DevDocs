Сервис (не путайте общее название с конкретным типом) работает так же как фабрика.
Разница в том, что сервис использует конструктор, поэтому, когда используете его в первый раз, он выполнит new Foo();
для создания экземпляра объекта.
Имейте в виду, что этот же объект вернется и в других местах, если использовать там этот сервис.


Сервисы обычно используют не для логики презентаций, а для слоя бизнес-логики. Это общение с backend через REST.
Методы "сервисов":
- Constant, Value
- Factory - метод возвращает объект или функцию (custom services), поэтому мы можем использовать замыкания, или возвращать объект host, к которому можно привязывать методы. Можно создавать приватную и публичную области видимости. Все Фабрики становятся Сервисами
- Service (эквивалент Factory) - метод создаёт новый объект-синглтон, который общается с бэкендом и предоставляет инструменты для работы с бизнес-логикой. Сервис – это объект constructor, который вызывают через ключевое слово new, в связи с чем наша логика связывается с сервисом при помощи ключевого слова this.
- Provider

Main services:
$compile, $scope, $rootScope, $http, $resource, $interval, $timeout, $animate, $browser, $location, $log

$route
обычно используется в сочетании с директивой ngView.

$q
Если нужно выполнить код независимо от результата promise, используют finally обработчик, который вызывается всегда.
Так же блок finally не влияет на дальнейшую обработку, так как он не меняет тип promise результата.
$q.all следует использовать в случаях, когда необходимо синхронизировать выполнение асинхронных функций.
$q.when своего рода прокси функция, которая принимает либо promise либо обычное значение, а возвращает всегда promise.

Обработка ошибок:
asyncFunction().then(function() {
  return somethingElseAsync();
}).catch(function(err) {
  errorHandler(err);
});

Errors handling in Q library - http://bahmutov.calepin.co/error-handling-in-promises.html