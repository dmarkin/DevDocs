http://es6-features.org
http://es6katas.org/ - обучалка с тестами
http://www.es6fiddle.net/ - примеры использования
http://kangax.github.io/compat-table/es6/ - совместимость
+ http://dou.ua/lenta/articles/ecmascript-6-is-coming/


Переменные let:
- Видны только после объявления и только в текущем блоке.
- Нельзя переобъявлять (в том же блоке).
- При объявлении переменной в цикле for(let …) – она видна только в этом цикле. Причём каждой итерации соответствует своя переменная let.

const
- Объявление const задаёт константу, то есть переменную, которую нельзя изменить
- Если в константу присвоен объект (это возможно!), то от изменения защищена сама константа, но не свойства внутри неё

Деструктуризация (destructuring assignment) – это особый синтаксис присваивания, при котором можно присвоить
массив или объект сразу нескольким переменным, разбив его на части.

spread (...) -  должно стоять только последним элементом в списке слева
'use strict';

let [firstName, lastName, ...rest] = "Юлий Цезарь Император Рима".split(" ");
alert(firstName); // Юлий
alert(lastName);  // Цезарь
alert(rest);      // Император,Рима (массив из 2х элементов)

// значения по умолчанию
let [firstName="Гость", lastName="Анонимный"] = [];
alert(firstName); // Гость
alert(lastName);  // Анонимный

Деструктуризацию можно использовать и с объектами.
'use strict';

let options = {
  title: "Меню",
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Меню
alert(width);  // 100
alert(height); // 200

let {width: w, height: h, title} = options;

alert(title);  // Меню
alert(w);      // 100
alert(h);      // 200

let {width=100, height=200, title} = options;

alert(title);  // Меню
alert(width);  // 100
alert(height); // 200

Чтобы избежать интерпретации {a, b} как блока, нужно обернуть всё присваивание в скобки:

let a, b;
({a, b} = {a:5, b:6}); // внутри выражения это уже не блок

Если объект или массив содержат другие объекты или массивы, и их тоже хочется разбить на переменные –
при деструктуризации нужно лишь сохранить ту же структуру, что и исходный объект/массив.
Деструктуризации можно как угодно сочетать и вкладывать друг в друга.

Функции
Параметры по умолчанию используются при отсутствующем аргументе или равном undefined
Параметры по умолчанию могут быть не только значениями, но и выражениями.

Оператор spread вместо arguments
Чтобы получить массив аргументов, можно использовать оператор …, например:
function showName(firstName, lastName, ...rest)
В rest попадёт массив всех аргументов, начиная со второго.
Заметим, что rest – настоящий массив, с методами map, forEach и другими, в отличие от arguments.

Ex.
Math.max(...numbers);
    is the same as
Math.max.apply(Math, numbers);

! В свойстве name у функции находится её имя.
let f = function g() {}; имеем f.name === g, g.name === undefined
function g() {}; имеем g.name === g

! Объявление функции Function Declaration, сделанное в блоке, видно только в этом блоке.

Функции-стрелки
let inc = x => x + 1; эквивалентно let inc = function(x) { return x + 1; };
С фигурными скобками требуют явного return:
let inc = x => {return x + 1};


- Функции-стрелки не имеют своего this
- Функции стрелки нельзя запускать с new
   Отсутствие у функции-стрелки "своего this" влечёт за собой естественное ограничение: такие функции нельзя использовать в качестве конструктора, то есть нельзя вызывать через new.
   Поиск this в ней осуществляется выше в замыкании.
- Функции-стрелки не имеют своего arguments
   В качестве arguments используются аргументы внешней «обычной» функции.

Сохранение внешнего this и arguments удобно использовать для форвардинга вызовов и создания декораторов.

Строки
let str = `обратные
 кавычки`; - в них разрешен перевод строк

Интерполяция при помощи ${…}

Можно использовать свою функцию шаблонизации для строк. Название этой функции ставится перед первой обратной кавычкой:
let str = func`моя строка`;
Эта функция будет автоматически вызвана и получит в качестве аргументов строку, разбитую по вхождениям параметров ${…} и сами эти параметры.
В примере выше видно, что строка разбивается по очереди на части: «кусок строки» – «параметр» – «кусок строки» – «параметр».

Улучшена поддержка юникода

Добавлены ряд полезных методов общего назначения:
    str.includes(s) – проверяет, включает ли одна строка в себя другую, возвращает true/false.
    str.endsWith(s) – возвращает true, если строка str заканчивается подстрокой s.
    str.startsWith(s) – возвращает true, если строка str начинается со строки s.
    str.repeat(times) – повторяет строку str times раз.

Объекты
Улучшения в описании свойств:
    Запись name: name можно заменить на просто name
    Если имя свойства находится в переменной или задано выражением expr, то его можно указать в квадратных скобках [expr].
    Свойства-функции можно оформить как методы: "prop: function() {}" → "prop() {}".

В методах работает обращение к свойствам прототипа через super.parentProperty.

Для работы с прототипом:
    Object.setPrototypeOf(obj, proto) – метод для установки прототипа.
    obj.__proto__ – ссылка на прототип.

Дополнительно:
    Метод Object.assign(target, src1, src2...) – копирует только собственные перечисляемые свойства из всех аргументов в первый объект.
    Метод Object.is(value1, value2) проверяет два значения на равенство.
        Object.is(+0, -0); // false
        Object.is(NaN, NaN); // true

Классы
// Функция constructor запускается при создании new User, остальные методы записываются в User.prototype.
'use strict';

class User {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }
}


Классы-коллекции
Set - списки слов
Map - набора пар ключ:значение

Циклы for-in нужны для перебора свойств объекта.
Циклы for-of нужны для перебора данных, например, значений массива. Допускают мспользование break, continue и return

Цикл for-of поддерживается во всех текущих версиях Firefox.
Он есть в Chrome, но чтобы был доступен, нужно открыть chrome://flags и включить «Экспериментальный JavaScript».
Он также работает в браузере Edge от Microsoft, но его нет ни в одной версии Internet Explorer.
Если вы хотите пользоваться этим новым синтаксисом, но вам нужно поддерживать IE или Safari,
вы можете воспользоваться компилятором вроде Babel (http://babeljs.io/) или Traceur (https://github.com/google/traceur-compiler#what-is-traceur) от Google,
чтобы транслировать ваш код ES6 в ES5, который поддерживают все браузеры.

На серверной стороне вам не нужен компилятор, просто используйте for-of в io.js (или Node, с флагом --harmony) уже сейчас.



http://frontender.info/es6-in-depth-generators
Функции-генераторы начинаются с function*. Генераторы — это итераторы
Внутри функции-генератора есть ключевое слово yield с синтаксисом, похожим на return.
Отличие в том, что функция (в том числе функция-генератор) может вернуть значение только один раз,
но отдать значение функция-генератор может любое количество раз.
Выражение yield приостанавливает выполнение генератора, так что его можно позже возобновить.

После того, как генератор вызван, он ещё не начнёт выполняться. Вместо этого он вернёт приостановленный объект Generator
Каждый раз, как вызывается метод .next() у объекта Generator, вызов функции оттаивает и выполняется,
пока не достигнет следующего выражения yield.

При последнем вызове iter.next() поле .done результата стало равно true.
Добраться до конца функции — это всё равно, что вернуть undefined, и именно поэтому поле .value результата равно undefined.

Асинхронность и генераторы
// Синхронный код, производящий шум
function makeNoise() {
  shake();
  rattle();
  roll();
}

// Асинхронный код, производящий шум
// Возвращает объект Promise, который разрешится,
// когда мы закончим шуметь
function makeNoise_async() {
  return Q.async(function* () {
    yield shake_async();
    yield rattle_async();
    yield roll_async();
  });
}

Из браузеров пока что генераторы поддерживают только Firefox 27+ и Chrome 39+.

Классы
http://frontender.info/es6-classes-final/
В отличие от функций, определения классов не поднимаются. Причина этого ограничения в том, что классы могут быть наследниками.

Тело класса может содержать только методы, но не свойства.
Если свойство-значение, всё же, необходимо, то можно создать геттер, который будет нужное значение возвращать.

class Foo {
    constructor(prop) {
        this.prop = prop;
    }
    static staticMethod() {
        return 'classy';
    }
    prototypeMethod() {
        return 'prototypical';
    }
}
let foo = new Foo(123);

Метод constructor определяет функцию, которая представляет собой класс:
Foo === Foo.prototype.constructor

Статические методы (или методы класса) являются методами самого Foo
Как правило, они используются для операций, не требующих наличия объекта (this), например – для фабричных, также статическими удобно делать константы
class Menu {
  static get elemClass() {
    return "menu"
  }
}

Прототипные методы Foo являются и свойствами Foo.prototype. Как правило, эти методы и наследуются экземплярами Foo.

Геттеры и сеттеры
class MyClass {
    get prop() {
        return 'getter';
    }
    set prop(value) {
        console.log('setter: ' + value);
    }
}

> let inst = new MyClass();
> inst.prop = 123;
setter: 123
> inst.prop
'getter'

Метод-генератор
Если вы определите метод с «*» в начале, то получите _метод генератор_

Наследование
class Animal { }
class Rabbit extends Animal { } // Rabbit - Child, Animal - Parent

alert( Rabbit.prototype.__proto__ == Animal.prototype ); // true

Методы родителя можно переопределить в наследнике. При этом для обращения к родительскому методу используют super.someMethod().
Конструктор constructor родителя наследуется автоматически. То есть, если в потомке не указан свой constructor, то используется родительский.
Если же у потомка свой constructor, то, чтобы в нём вызвать конструктор родителя – используется синтаксис super() с аргументами для родителя.
Для такого вызова есть небольшие ограничения:
    Вызвать конструктор родителя можно только изнутри конструктора потомка. В частности, super() нельзя вызвать из произвольного метода.
    В конструкторе потомка мы обязаны вызвать super() до обращения к this. До вызова super не существует this, так как по спецификации в этом случае именно super инициализует this.

class Animal {

  constructor(_name) {

    Object.defineProperty(this, "name", {
        get: function(){
            return _name;
        },
        set: function(newValue){
            if(newValue.length > 10){
                throw new Error('Name max-length error');
            } else {
                _name = newValue;
            }
        }
    });
  }

  showName() {
    console.log('Animal name is ' + this.name);
  }

}

class Dog extends Animal{
    constructor(_name, _age) {
        super(_name);
        Object.defineProperty(this, "age", {
            get: function(){
                return _age;
            },
            set: function(){
                throw new Error('Property "age" invariant');
            }
        });
      }
    sayWoof() {
              console.log('Dog ' + this.name + ' says woof..woof');
    }
    showAge() {
              console.log('Dog ' + this.name + ' age is ' + this.age);
    }
}

let barbos = new Dog('barbos', 4);

barbos.showName() // Animal name is barbos
barbos.sayWoof() // Dog barbos says woof..woof
barbos.showAge(); //Dog barbos age is 4

// вешаем обработчик при создании и убираем по клику
class Item {
    constructor(elem) {
        this._elem = elem;
        this._doSomethingHandler = event => this._doSomething(event);
        elem.addEventListener("click", this._doSomethingHandler, false);
    }
    _doSomething(event) {
        this._elem.removeEventListener("click", this._doSomethingHandler, false);
        // some code
    }
}

Тип данных Symbol
Новый примитивный тип данных Symbol служит для создания уникальных идентификаторов.
let sym = Symbol(); // typeof sym == 'symbol'
Все символы уникальны. Символы с одинаковым именем не равны друг другу.
У функции Symbol есть необязательный аргумент «имя символа».
let sym = Symbol("name");

Глобальные символы
Существует «глобальный реестр» символов, который позволяет, при необходимости, иметь общие «глобальные» символы,
которые можно получить из реестра по имени.
Для чтения (или создания, при отсутствии) «глобального» символа служит вызов Symbol.for(имя).
У вызова Symbol.for, который возвращает символ по имени, есть обратный вызов – Symbol.keyFor(sym).
Он позволяет получить по глобальному символу его имя
Symbol.keyFor возвращает undefined, если символ не глобальный

Использование символов
Символы можно использовать в качестве имён для свойств объекта (оно не является перечислимым)
свойство-символ недоступно, если обратиться к его названию через точку
"символьные" свойства объекта игнорируются во время вызова JSON.stringify()

Object.getOwnPropertySymbols - получить все символы объекта

Модули
Модулем считается файл с кодом. В этом файле ключевым словом export помечаются переменные и функции,
которые могут быть использованы снаружи. Другие модули могут подключать их через вызов import.

http://webtackles.ru/javascript/js-module-bundling/
Используйте преобразователь кода (например, Babel или Traceur) для преобразования кода из ES6 в ES5 в любом формате:
CommonJS, AMD или UMD. Затем пропустите его через упаковщик модулей: Browserify или Webpack, чтобы создать один или несколько
связанных файлов.
SystemJS - построен на ES6 загрузчике модулей

!! На текущий момент модули требуют системы сборки на сервере.

Promises

let promise = new Promise(function(resolve, reject) {
  // maybe do some async stuff in here
  resolve('result');
});

Достаточно вызвать resolve, когда обещание выполнено, или вызвать reject, если что-то пошло не так. Также можно сгенерировать исключение.
Если вы хотите обернуть значение в обещание, которое будет выполнено немедленно, можно просто написать Promise.resolve(value).
В обратном случае достаточно написать Promise.reject(error).
