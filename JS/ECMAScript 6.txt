http://es6-features.org


Классы-коллекции
Set - списки слов
Map - набора пар ключ:значение

Циклы for-in нужны для перебора свойств объекта.
Циклы for-of нужны для перебора данных, например, значений массива. Допускают мспользование break, continue и return

Цикл for-of поддерживается во всех текущих версиях Firefox.
Он есть в Chrome, но чтобы был доступен, нужно открыть chrome://flags и включить «Экспериментальный JavaScript».
Он также работает в браузере Edge от Microsoft, но его нет ни в одной версии Internet Explorer.
Если вы хотите пользоваться этим новым синтаксисом, но вам нужно поддерживать IE или Safari,
вы можете воспользоваться компилятором вроде Babel (http://babeljs.io/) или Traceur (https://github.com/google/traceur-compiler#what-is-traceur) от Google,
чтобы транслировать ваш код ES6 в ES5, который поддерживают все браузеры.

На серверной стороне вам не нужен компилятор, просто используйте for-of в io.js (или Node, с флагом --harmony) уже сейчас.



http://frontender.info/es6-in-depth-generators
Функции-генераторы начинаются с function*. Генераторы — это итераторы
Внутри функции-генератора есть ключевое слово yield с синтаксисом, похожим на return.
Отличие в том, что функция (в том числе функция-генератор) может вернуть значение только один раз,
но отдать значение функция-генератор может любое количество раз.
Выражение yield приостанавливает выполнение генератора, так что его можно позже возобновить.

После того, как генератор вызван, он ещё не начнёт выполняться. Вместо этого он вернёт приостановленный объект Generator
Каждый раз, как вызывается метод .next() у объекта Generator, вызов функции оттаивает и выполняется,
пока не достигнет следующего выражения yield.

При последнем вызове iter.next() поле .done результата стало равно true.
Добраться до конца функции — это всё равно, что вернуть undefined, и именно поэтому поле .value результата равно undefined.

Асинхронность и генераторы
// Синхронный код, производящий шум
function makeNoise() {
  shake();
  rattle();
  roll();
}

// Асинхронный код, производящий шум
// Возвращает объект Promise, который разрешится,
// когда мы закончим шуметь
function makeNoise_async() {
  return Q.async(function* () {
    yield shake_async();
    yield rattle_async();
    yield roll_async();
  });
}

Из браузеров пока что генераторы поддерживают только Firefox 27+ и Chrome 39+.

Классы
http://frontender.info/es6-classes-final/
В отличие от функций, определения классов не поднимаются. Причина этого ограничения в том, что классы могут быть наследниками.

Тело класса может содержать только методы, но не свойства.

class Foo {
    constructor(prop) {
        this.prop = prop;
    }
    static staticMethod() {
        return 'classy';
    }
    prototypeMethod() {
        return 'prototypical';
    }
}
let foo = new Foo(123);

Метод constructor определяет функцию, которая представляет собой класс:
Foo === Foo.prototype.constructor

Статические методы (или методы класса) являются методами самого Foo

Прототипные методы Foo являются и свойствами Foo.prototype. Как правило, эти методы и наследуются экземплярами Foo.

Геттеры и сеттеры
class MyClass {
    get prop() {
        return 'getter';
    }
    set prop(value) {
        console.log('setter: '+value);
    }
}

> let inst = new MyClass();
> inst.prop = 123;
setter: 123
> inst.prop
'getter'

Метод-генератор
Если вы определите метод с «*» в начале, то получите _метод генератор_