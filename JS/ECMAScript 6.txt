http://es6-features.org
http://es6katas.org/ - обучалка с тестами
http://www.es6fiddle.net/ - примеры использования
http://kangax.github.io/compat-table/es6/ - совместимость
+ http://dou.ua/lenta/articles/ecmascript-6-is-coming/


Переменные let:
- Видны только после объявления и только в текущем блоке.
- Нельзя переобъявлять (в том же блоке).
- При объявлении переменной в цикле for(let …) – она видна только в этом цикле. Причём каждой итерации соответствует своя переменная let.

const
- Объявление const задаёт константу, то есть переменную, которую нельзя изменить
- Если в константу присвоен объект, то от изменения защищена сама константа, но не свойства внутри неё

Деструктуризация (destructuring assignment) – это особый синтаксис присваивания, при котором можно присвоить
массив или объект сразу нескольким переменным, разбив его на части.

spread (...) -  должно стоять только последним элементом в списке слева
'use strict';

let [firstName, lastName, ...rest] = "Юлий Цезарь Император Рима".split(" ");
alert(firstName); // Юлий
alert(lastName);  // Цезарь
alert(rest);      // Император,Рима (массив из 2х элементов)

// значения по умолчанию
let [firstName="Гость", lastName="Анонимный"] = [];
alert(firstName); // Гость
alert(lastName);  // Анонимный

Деструктуризацию можно использовать и с объектами.
'use strict';

let options = {
  title: "Меню",
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Меню
alert(width);  // 100
alert(height); // 200

let {width: w, height: h, title} = options;

alert(title);  // Меню
alert(w);      // 100
alert(h);      // 200

let {width=100, height=200, title} = options;

alert(title);  // Меню
alert(width);  // 100
alert(height); // 200

Чтобы избежать интерпретации {a, b} как блока, нужно обернуть всё присваивание в скобки:

let a, b;
({a, b} = {a:5, b:6}); // внутри выражения это уже не блок

Если объект или массив содержат другие объекты или массивы, и их тоже хочется разбить на переменные –
при деструктуризации нужно лишь сохранить ту же структуру, что и исходный объект/массив.
Деструктуризации можно как угодно сочетать и вкладывать друг в друга.

Функции
Параметры по умолчанию используются при отсутствующем аргументе или равном undefined
Параметры по умолчанию могут быть не только значениями, но и выражениями.

Оператор spread вместо arguments
Чтобы получить массив аргументов, можно использовать оператор …, например:
function showName(firstName, lastName, ...rest)
В rest попадёт массив всех аргументов, начиная со второго.
Заметим, что rest – настоящий массив, с методами map, forEach и другими, в отличие от arguments.

Ex.
Math.max(...numbers);
    is the same as
Math.max.apply(Math, numbers);


Классы-коллекции
Set - списки слов
Map - набора пар ключ:значение

Циклы for-in нужны для перебора свойств объекта.
Циклы for-of нужны для перебора данных, например, значений массива. Допускают мспользование break, continue и return

Цикл for-of поддерживается во всех текущих версиях Firefox.
Он есть в Chrome, но чтобы был доступен, нужно открыть chrome://flags и включить «Экспериментальный JavaScript».
Он также работает в браузере Edge от Microsoft, но его нет ни в одной версии Internet Explorer.
Если вы хотите пользоваться этим новым синтаксисом, но вам нужно поддерживать IE или Safari,
вы можете воспользоваться компилятором вроде Babel (http://babeljs.io/) или Traceur (https://github.com/google/traceur-compiler#what-is-traceur) от Google,
чтобы транслировать ваш код ES6 в ES5, который поддерживают все браузеры.

На серверной стороне вам не нужен компилятор, просто используйте for-of в io.js (или Node, с флагом --harmony) уже сейчас.



http://frontender.info/es6-in-depth-generators
Функции-генераторы начинаются с function*. Генераторы — это итераторы
Внутри функции-генератора есть ключевое слово yield с синтаксисом, похожим на return.
Отличие в том, что функция (в том числе функция-генератор) может вернуть значение только один раз,
но отдать значение функция-генератор может любое количество раз.
Выражение yield приостанавливает выполнение генератора, так что его можно позже возобновить.

После того, как генератор вызван, он ещё не начнёт выполняться. Вместо этого он вернёт приостановленный объект Generator
Каждый раз, как вызывается метод .next() у объекта Generator, вызов функции оттаивает и выполняется,
пока не достигнет следующего выражения yield.

При последнем вызове iter.next() поле .done результата стало равно true.
Добраться до конца функции — это всё равно, что вернуть undefined, и именно поэтому поле .value результата равно undefined.

Асинхронность и генераторы
// Синхронный код, производящий шум
function makeNoise() {
  shake();
  rattle();
  roll();
}

// Асинхронный код, производящий шум
// Возвращает объект Promise, который разрешится,
// когда мы закончим шуметь
function makeNoise_async() {
  return Q.async(function* () {
    yield shake_async();
    yield rattle_async();
    yield roll_async();
  });
}

Из браузеров пока что генераторы поддерживают только Firefox 27+ и Chrome 39+.

Классы
http://frontender.info/es6-classes-final/
В отличие от функций, определения классов не поднимаются. Причина этого ограничения в том, что классы могут быть наследниками.

Тело класса может содержать только методы, но не свойства.

class Foo {
    constructor(prop) {
        this.prop = prop;
    }
    static staticMethod() {
        return 'classy';
    }
    prototypeMethod() {
        return 'prototypical';
    }
}
let foo = new Foo(123);

Метод constructor определяет функцию, которая представляет собой класс:
Foo === Foo.prototype.constructor

Статические методы (или методы класса) являются методами самого Foo

Прототипные методы Foo являются и свойствами Foo.prototype. Как правило, эти методы и наследуются экземплярами Foo.

Геттеры и сеттеры
class MyClass {
    get prop() {
        return 'getter';
    }
    set prop(value) {
        console.log('setter: '+value);
    }
}

> let inst = new MyClass();
> inst.prop = 123;
setter: 123
> inst.prop
'getter'

Метод-генератор
Если вы определите метод с «*» в начале, то получите _метод генератор_

Модули
http://webtackles.ru/javascript/js-module-bundling/
Используйте преобразователь кода (например, Babel или Traceur) для преобразования вашего кода из ES6 в ES5 в любом формате:
CommonJS, AMD или UMD. Затем пропустите его через упаковщик модулей: Browserify или Webpack, чтобы создать один или несколько
связанных файлов.
SystemJS - построен на ES6 загрузчике модулей