Парадигмы ООП:

- Инкапсуляция (Сокрытие типов данных, сокрытие членов структуры - модификаторы, сокрытие частей программных систем)
- Наследование
Example:
function A(type){
this.type = type;
this.x = 10;
};
A.prototype.getType = function(){return this.type};
A.prototype.getX = function(){return this.x};

function B(type){}; //Наследуем класс А используя prototype
var b = Object.create(new A()); // именно так, а не B.prototype = new A(); var b = new B('cool');
b.x // 10 - назначеное A
b.type // cool

function C(type){
    A.call(this, type);
    //При вызове С через new создается новый объект (this),
    //A назначает ему свойства x и type, но не ставит __proto__, так как не вызвана через New
};
var c = new C("cool");
c.x // 10;
c.type // cool

- Полиморфизм
- Абстракция
- Посылка сообщений
- Повторное использование

SOLID - five basic principles of object-oriented programming and design

Single responsibility principle
    a class should have only a single responsibility (i.e. only one potential change in the software's specification should be able to affect the specification of the class)

Open/closed principle
    “software entities … should be open for extension, but closed for modification.”

Liskov substitution principle
    “objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.” See also design by contract.

Interface segregation principle
    “many client-specific interfaces are better than one general-purpose interface.”

Dependency inversion principle
    one should “Depend upon Abstractions. Do not depend upon concretions.”
