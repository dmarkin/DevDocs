**useState**
``const [state, setState] = useState(initialState);``
Далее для обновления state вызываем ``setState(newState or prevState => calculatedNewState)``
Если функция обновления возвращает абсолютно такой же результат как и текущее состояние, то последующие повторные
рендеры будут полностью пропущены - React досрочно выйдет из хука без повторного рендера дочерних элементов и запуска
эффектов.
Обновленный state перезаписывает предыдущий!

**useEffect(didUpdate);**
Принимает функцию, которая содержит императивный код, возможно, с эффектами.
По умолчанию эффекты запускаются после каждого завершённого рендеринга (разметки и отрисовки) и перед любыми новыми
рендерами.
Внутри допускаются мутации, подписки, таймеры, обработка событий, логирование и другие побочные эффекты
Эффект отработает только при изменении props.source (если [] - отработает один раз). Каждое значение, на которое
ссылается функция эффекта, должно также появиться в массиве зависимостей
``useEffect(
     () => {
       const subscription = props.source.subscribe();
       return () => { // запустится при размонтировании
         subscription.unsubscribe();
       };
     },
     [props.source],
   );``

**useLayoutEffect(didUpdate);**
запускается синхронно после всех изменений DOM. Используйте его для чтения макета из DOM и синхронного повторного
рендеринга. Обновления, запланированные внутри useLayoutEffect, будут полностью применены синхронно перед тем, как браузер получит шанс осуществить отрисовку.

**useContext**
``const value = useContext(MyContext);``
Принимает объект контекста (значение, возвращённое из React.createContext) и возвращает текущее значение
контекста для этого контекста. Текущее значение контекста определяется пропом value ближайшего <MyContext.Provider> над
вызывающим компонентом в дереве
Когда ближайший <MyContext.Provider> над компонентом обновляется, этот хук вызовет повторный рендер с последним
значением контекста, переданным этому провайдеру MyContext. Даже если родительский компонент использует React.memo или
реализует shouldComponentUpdate, то повторный рендер будет выполняться, начиная c компонента, использующего
useContext.

**useReducer**
``const [state, dispatch] = useReducer(reducer, initialArg, init);``
Альтернатива для useState, обычно этот хук предпочтительнее useState, когда у вас сложная логика состояния,
которая включает в себя несколько значений, или когда следующее состояние зависит от предыдущего. Поведение
аналогично useState

useReducer without Redux
https://itnext.io/life-after-redux-21f33b7f189e

**useCallback**
``const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b],
);``
Возвращает мемоизированный колбэк.
useCallback(fn, deps) — это эквивалент useMemo(() => fn, deps).

**useMemo**
``const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);``
Возвращает мемоизированное значение.
useMemo будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из
зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.
Помните, что функция, переданная useMemo, запускается во время рендеринга. Не делайте там ничего, что вы
обычно не делаете во время рендеринга. Например, побочные эффекты принадлежат useEffect, а не useMemo.
Если массив не был передан, новое значение будет вычисляться при каждом рендере.

**useRef**
``const refContainer = useRef(initialValue);``
useRef возвращает изменяемый ref-объект, свойство current которого инициализируется переданным аргументом (initialValue).
Возвращённый объект будет сохраняться в течение всего времени жизни компонента.
Может быть удобен для сохранения любого мутируемого значения. useRef не уведомляет, когда изменяется его содержимое.
Мутирование свойства current не вызывает повторный рендер.
``function TextInputWithFocusButton() {
    const inputEl = useRef(null);
    const onButtonClick = () => {
      // `current` указывает на смонтированный элемент `input`
      inputEl.current.focus();
    };
    return (
      <>
        <input ref={inputEl} type="text" />
        <button onClick={onButtonClick}>Установить фокус на поле ввода</button>
      </>
    );
  }``

**useImperativeHandle**
``useImperativeHandle(ref, createHandle, [deps])``
useImperativeHandle настраивает значение экземпляра, которое предоставляется родительским компонентам при использовании ref.

**useDebugValue(value)**
может использоваться для отображения метки для пользовательских хуков в React DevTools.
наиболее ценно для пользовательских хуков, которые являются частью общих библиотек.
