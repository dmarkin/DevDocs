**Замыкания и функции внутри**
Все переменные внутри функции — это свойства специального внутреннего объекта LexicalEnvironment.
!!! **при выполнении функций действуют области видимости переменных, которые имелись на момент их определения (создания,
объявления), а не на момент вызова.** Большинство функций вызываются внутри той же цепочки областей видимости, которая
действовала на момент определения функции, и в этой ситуации факт образования замыкания не имеет никакого значения.
Интересные особенности замыканий начинают проявляться, когда их вызов производится в другой цепочке областей
видимости, отличной от той, что действовала на момент определения. Чаще всего это происходит, когда объект вложенной
функции возвращается функцией, вмещающей ее определение. (Флэнаган)

При запуске функция создает объект LexicalEnvironment, записывает туда аргументы, функции и переменные.
 Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является
  частным случаем лексического окружения.
•	Каждая функция при создании получает ссылку [[Scope]] на объект с переменными, в контексте которого она была создана.
•	При запуске функции создается новый объект с переменными. В него копируется ссылка на внешний объект из [[Scope]].
•	При поиске переменных он осуществляется сначала в текущем объекте переменных, а потом — по этой ссылке. Благодаря
 этому в функции доступны внешние переменные.
Сложно! Замыканием функции называется сама эта функция, плюс вся цепочка LexicalEnvironment, которая при этом образуется.
 Можно сказать и по-другому: «замыкание — это функция и все внешние переменные, которые ей доступны».

Замыканиями в ECMAScript являются:
•	с теоретической точки зрения: все функции, т.к. все они запоминают при создании лексический контекcт (и даже в
 глобальной функции, обращение к глобальной переменной – есть обращение к свободной переменной, а потому – в силу вступает
  общий для всех функций механизм цепи областей видимости);
•	с практической точки зрения: интерес составляют функции, которые:
o	переживают свой лексический контекст (т.е. являются функциональными значениями, возвращаемыми из функции);
o	обращаются в коде к свободным переменным.
Применение замыканий
На практике замыкания позволяют создавать выразительные конструкции, позволяющие кастомизировать различные вычисления по
 условию, определяемому фунаргом. Примером может служить, например, функция сортировки, принимающая параметром функцию,
  определяющую порядок сортировки её аргументов:
	[1, 2, 3].sort(function (a, b) {
  ... // условия сортировки
});
Или, например, так называемые, отображающие функционалы, как метод массива .map (доступен не во всех реализациях,
 тестируйте в SpiderMonkey, начиная с версии 1.6), который отображает (map) новый массив по условию функционального 
 аргумента:
	[1, 2, 3].map(function (element) {
  return element * 2;
}); // [2, 4, 6]
Часто, удобно организовывать функции поиска с помощью функциональных аргументов, определяющих практически неограниченные
 условия поиска:
	someCollection.find(function (element) {
  return element.someProperty === 'searchCondition';
});
Также, можно отметить применяющие функционалы, как, например, метод .forEach, который применяет (apply) фунарг к
 элементам массива:
	[1, 2, 3].forEach(function (element) {
  if (element % 2 != 0) {
    alert(element);
  }
}); // 1, 3
Кстати, методы объектов-функций .apply и .call, также уходят корнями в применяющие функционалы функционального
 программирования; здесь, мы видим их в роли применяющих функционалов – функция применяется к аргументам (к списку
  (массиву) аргументов – в apply, и к позиционным аргументам – в call):
	(function () {
  alert([].join.call(arguments, ';')); // 1;2;3
}).apply(this, [1, 2, 3]);
Ещё одним важным применением замыканий являются отложенные вызовы:
	var a = 10;
setTimeout(function () {
  alert(a); // 10, через секунду
}, 1000);
Функции обратного вызова (callback):
	...
var a = 10;
// только для примера
xmlHttpRequestObject.onreadystatechange = function () {
  // callback, который вызовется отложенно,
  // когда данные будут готовы;
  // переменная "а" здесь доступна,
  // даже несмотря на то, что контекст,
  // породивший "а" уже завершился
  alert(a); // 10
};
..
Создание обособленной области видимости с целью сокрытия вспомогательных сущностей (инициализирующее пространство):
	var testObject = {};
 
// инициализация
(function (object) {
  var a = 10;
  object.getA = function _getA() {
    return a;
  };
})(testObject);
 
alert(testObject.getA()); // получение замкнутой "а" - 10 

Перевод статьи R. Cornford-a: Часть 1, Часть 2

Вложенные функции
Вложенные функции могут быть объявлены и как Function Declaration и как Function Expression. Вложенную функцию можно
 возвратить через return.

Управление памятью
Объект переменных внешней функции существует в памяти до тех пор, пока существует хоть одна внутренняя функция, 
ссылающаяся на него через свойство [[Scope]].

[[Scope]] для new Function - исключение из общего правила присвоения [[Scope]].
Функция создаётся вызовом new Function(params, code)
Params - параметры функции через запятую в виде строки, code - код функции в виде строки.
!!! Этот способ используется очень редко, но в отдельных случаях бывает весьма полезен, так как позволяет конструировать
 функцию во время выполнения программы, к примеру, из данных, полученных с сервера или от пользователя.
При создании функции с использованием new Function (конструктор), её свойство [[Scope]] ссылается не на текущий
 LexicalEnvironment, а на window ! Конструктор Function можно вызывать и с new и без, в данном случае эти записи будут
  эквивалентны
