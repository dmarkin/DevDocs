https://github.com/nnupoor/js_designpatterns

Чистая функция
При вызове такой функции с одинаковыми параметрами, она всегда производит одинаковый результат.
Это значит, что у функции нет никаких побочных эффектов или зависимости от состояния (времени, свойств объекта, Ajax).
Такой тип функций проще для понимания, так как любые значения, влияющие на результат, передаются явно в качестве аргументов.

------------------------------------------------------------------------------------------------------------------------
When a script uses document.write, that prevents it from being loaded asynchronously.
Many of 3rd-party scripts use it.

------------------------------------------------------------------------------------------------------------------------

Каррирование (Currying)
Especially useful with more advanced functional feature - combinatorics

Обычная функция и ее вызов
var greet = function(greeting, name) {
  console.log(greeting + ", " + name);
};
greet("Hello", "Heidi"); //"Hello, Heidi"


Каррированная функция и ее вызовы
Важен порядок аргументов!
!? http://ramdajs.com/

var greetCurried = function(greeting) {
  return function(name) {
    console.log(greeting + ", " + name);
  };
};
var greetHello = greetCurried("Hello");
greetHello("Heidi"); //"Hello, Heidi"
greetHello("Eddie"); //"Hello, Eddie"
greetCurried("Hi there")("Howard"); //"Hi there, Howard"

В общем случае, пример создания и вызова каррированной функции без ()()()...-hell
// not handle all of the edge cases, such as missing or optional parameters
var curryIt = function(uncurried) {
  var parameters = Array.prototype.slice.call(arguments, 1);
  return function() {
    return uncurried.apply(this, parameters.concat(
      Array.prototype.slice.call(arguments, 0)
    ));
  };
};

var greeter = function(greeting, separator, emphasis, name) {
  console.log(greeting + separator + name + emphasis);
};
var greetHello = curryIt(greeter, "Hello", ", ", ".");
greetHello("Heidi"); //"Hello, Heidi."
greetHello("Eddie"); //"Hello, Eddie."
var greetGoodbye = curryIt(greeter, "Goodbye", ", ");
greetGoodbye(".", "Joe"); //"Goodbye, Joe."

------------------------------------------------------------------------------------------------------------------------
Инструкции throw и try...catch
Инструкция try...catch состоит из блока try, который содержит одну или несколько инструкций, и блок catch,
которые содержит инструкции, определяющие порядок действий при выбросе исключения в блоке try. Иными словами,
если в блоке try будет выброшено исключение, то управление будет передано в блок catch.
Если в блоке try не возникнет исключений, то блок catch будет пропущен. Блок finally будет выполнен
после окончания работы блоков try и catch, вне зависимости от того, было ли выброшено исключение.

Блок finally содержит код, который будет выполнен после окончания работы блоков try и catch, но до того,
как будет выполнен код, который следует за инструкцией try...catch. Блок finally выполняется вне зависимости от того,
было ли выброшено исключение. Блок finally выполняется даже в том случае, если исключение не перехватывается в блоке catch.

В следующем примере открывается файл, затем в блоке try происходит вызов функции writeMyFile,
который может выбросить исключение. Если возникает исключение, то оно обрабатывается в блоке catch.
В любом случае файл будет закрыт функцией closeMyFile, вызов которой находится в блоке finally.

openMyFile();
try {
  writeMyFile(theData);
} catch(e) {
  handleError(e);
} finally {
  closeMyFile();
}

Если блок finally возвращает значение, то данное значение становится возвращаемым значением всей связки try-catch-finally.
Значения, возвращаемые блоками try и catch, будут проигнорированы.
Возможно вкладывать инструкции try...catch друг в друга.
------------------------------------------------------------------------------------------------------------------------
Синглтон
Единственный экземпляр класса

Фабрика
Множество экземпяров класса

Декоратор
Добавление функциональности к декорируемому компоненту

Модуль
Изолированный код, импорт/экспорт

Прокси-объект

Фасад (=Песочница) [структурный паттерн]
Скрывает методы реализации функциональности, предлагая API для взаимодействия с ним
Обеспечивает безопасность взаимодействия

Посредник (mediator) [поведенческий паттерн]
Пример из жизни: диспетчер в аэропорту
Позволяет ослабить связность кода

Наблюдатель (observer)
Либо подписчик/издатель
Позволяет ослабить связность кода

Эдди Османи
Оптимальной для расширения (поскольку обеспечивает низкую связность кода) и обеспечения безопасности веб-приложений является архитектура:
Медиатор (ядро приложения) - Фасад - Модули (должны быть независимыми друг от друга)