https://github.com/nnupoor/js_designpatterns

Чистая функция
При вызове такой функции с одинаковыми параметрами, она всегда производит одинаковый результат.
Это значит, что у функции нет никаких побочных эффектов или зависимости от состояния (времени, свойств объекта, Ajax).
Такой тип функций проще для понимания, так как любые значения, влияющие на результат, передаются явно в качестве аргументов.

------------------------------------------------------------------------------------------------------------------------
Линейные структуры данных: стеки и очереди.
Массивы в JavaScript имеют встроенную реализацию стека и очереди.
Стек хранит данные в последовательном порядке и удаляет последние добавленные данные.


// ES6
class Stack {
    constructor () {
        this._size = 0;
        this._storage = {};
    }

    push(data) {
        let size = ++this._size;
        this._storage[size] = data;
    }

    pop () {
        let size = this._size,
            deletedData;

        if (size) {
            deletedData = this._storage[size];

            delete this._storage[size];
            this._size--;

            return deletedData;
        }
    }
}

// ES5
function Stack() {
    this._size = 0;
    this._storage = {};
}

Stack.prototype.push = function(data) {
    var size = ++this._size;
    this._storage[size] = data;
};

Stack.prototype.pop = function() {
    var size = this._size,
        deletedData;

    if (size) {
        deletedData = this._storage[size];

        delete this._storage[size];
        this._size--;

        return deletedData;
    }
};

Очередь также хранит данные в последовательном порядке, но удаляет самые старые элементы.
// ES6
class Queue {
    constructor () {
        this._oldestIndex = 1;
        this._newestIndex = 1;
        this._storage = {};
    }

    size () {
        return this._newestIndex - this._oldestIndex;
    }

    enqueue (data) {
        this._storage[this._newestIndex] = data;
        this._newestIndex++;
    }

    dequeue () {
        let oldestIndex = this._oldestIndex,
            newestIndex = this._newestIndex,
            deletedData;

        if (oldestIndex !== newestIndex) {
            deletedData = this._storage[oldestIndex];
            delete this._storage[oldestIndex];
            this._oldestIndex++;

            return deletedData;
        }
    }
}

// ES5
function Queue() {
    this._oldestIndex = 1;
    this._newestIndex = 1;
    this._storage = {};
}

Queue.prototype.size = function() {
    return this._newestIndex - this._oldestIndex;
};

Queue.prototype.enqueue = function(data) {
    this._storage[this._newestIndex] = data;
    this._newestIndex++;
};

Queue.prototype.dequeue = function() {
    var oldestIndex = this._oldestIndex,
        newestIndex = this._newestIndex,
        deletedData;

    if (oldestIndex !== newestIndex) {
        deletedData = this._storage[oldestIndex];
        delete this._storage[oldestIndex];
        this._oldestIndex++;

        return deletedData;
    }
};

Односвязный список
В информатике представляет собой структуру данных, которая содержит последовательность связанных узлов.
Каждый узел содержит данные и указатель, который может указывать на другой узел.
Основные операции с односвязными списками:
Node
    data - здесь хранятся значения;
    next - указывает на следующий узел в списке.

SinglyList
    _length - извлекает количество узлов в списке;
    head - определяет узел, как головной элемент списка;
    add(value) - добавляет узел в список;
    searchNodeAt(position) - ищет в списке узел на n-ной позиции;
    remove(position) - удаляет узел из списка.

// ES6
class Node {
    constructor (data) {
        this.data = data;
        this.next = null;
    }
}

class SinglyList {
    constructor () {
        this._length = 0;
        this.head = null;
    }

    add(value) {
        let node = new Node(value),
            currentNode = this.head;

        // case if the list is void
        if (!currentNode) {
            this.head = node;
            this._length++;

            return node;
        }

        // case if the list isn't void
        while (currentNode.next) {
            currentNode = currentNode.next;
        }

        currentNode.next = node;
        this._length++;

        return node;
    }

    searchNodeAt(position) {
        let currentNode = this.head,
            length = this._length,
            count = 1,
            message = {failure: 'Failure: non-existent node in this list.'};

        // failed position argument
        if (length === 0 || position < 1 || position > length) {
            throw new Error(message.failure);
        }

        while (count < position) {
            currentNode = currentNode.next;
            count++;
        }

        return currentNode;
    }

    remove (position) {
        let currentNode = this.head,
            length = this._length,
            count = 0,
            message = {failure: 'Failure: non-existent node in this list.'},
            beforeNodeToDelete = null,
            nodeToDelete = null,
            deletedNode = null;

        // failed position argument
        if (position < 0 || position > length) {
            throw new Error(message.failure);
        }

        // case if position === 1
        if (position === 1) {
            this.head = currentNode.next;
            deletedNode = currentNode;
            currentNode = null;
            this._length--;

            return deletedNode;
        }

        // case if position > 1
        while (count < position) {
            beforeNodeToDelete = currentNode;
            nodeToDelete = currentNode.next;
            count++;
        }

        beforeNodeToDelete.next = nodeToDelete.next;
        deletedNode = nodeToDelete;
        nodeToDelete = null;
        this._length--;

        return deletedNode;
    }
}

// ES5
function Node(data) {
    this.data = data;
    this.next = null;
}

function SinglyList() {
    this._length = 0;
    this.head = null;
}

SinglyList.prototype.add = function(value) {
    var node = new Node(value),
        currentNode = this.head;

    // 1-ый случай: пустой список
    if (!currentNode) {
        this.head = node;
        this._length++;

        return node;
    }

    // 2-ой случай: не пустой список
    while (currentNode.next) {
        currentNode = currentNode.next;
    }

    currentNode.next = node;

    this._length++;

    return node;
};

SinglyList.prototype.searchNodeAt = function(position) {
    var currentNode = this.head,
        length = this._length,
        count = 1,
        message = {failure: 'Failure: non-existent node in this list.'};

    // 1-ый случай: неверная позиция
    if (length === 0 || position < 1 || position > length) {
        throw new Error(message.failure);
    }

    // 2-ой случай: верная позиция
    while (count < position) {
        currentNode = currentNode.next;
        count++;
    }

    return currentNode;
};

SinglyList.prototype.remove = function(position) {
    var currentNode = this.head,
        length = this._length,
        count = 0,
        message = {failure: 'Failure: non-existent node in this list.'},
        beforeNodeToDelete = null,
        nodeToDelete = null,
        deletedNode = null;

    // 1-ый случай: неверная позиция
    if (position < 0 || position > length) {
        throw new Error(message.failure);
    }

    // 2-ой случай: первый узел удален
    if (position === 1) {
        this.head = currentNode.next;
        deletedNode = currentNode;
        currentNode = null;
        this._length--;

        return deletedNode;
    }

    // 3-ий: все прочие узлы удалены
    while (count < position) {
        beforeNodeToDelete = currentNode;
        nodeToDelete = currentNode.next;
        count++;
    }

    beforeNodeToDelete.next = nodeToDelete.next;
    deletedNode = nodeToDelete;
    nodeToDelete = null;
    this._length--;

    return deletedNode;
};

Двусвязный список
Двусвязный список поддерживает все возможности односвязного списка и расширяет их для обработки в двух направлениях.
Поэтому мы можем обрабатывать данные в двусвязном списке от первого узла к последнему, и от последнего узла к первому.
Операции двусвязных списков
Node

    data - здесь хранятся значения;
    next - указывает на следующий узел в списке;
    previous - указывает на предыдущий узел в списке.

DoublyList

    _length - извлекает количество узлов в списке;
    head - назначает узел в качестве головного элемента списка;
    tail - назначает узел в качестве конечного элемента списка;
    add(value) - добавляет узел в список;
    searchNodeAt(position) - ищет узел на n-ной позиции в списке;
    remove(position) - удаляет узел из списка.

// ES6
class Node {
    constructor(value) {
        this.data = value;
        this.previous = null;
        this.next = null;
    }
}

class DoublyList {
    constructor () {
        this._length = 0;
        this.head = null;
        this.tail = null;
    }

    add(value) {
        let node = new Node(value);

        if (this._length) {
            this.tail.next = node;
            node.previous = this.tail;
            this.tail = node;
        } else {
            this.head = node;
            this.tail = node;
        }

        this._length++;

        return node;
    }

    searchNodeAt(position) {
        let currentNode = this.head,
            length = this._length,
            count = 1,
            message = {failure: 'Failure: non-existent node in this list.'};

        if (length === 0 || position < 1 || position > length) {
            throw new Error(message.failure);
        }

        while (count < position) {
            currentNode = currentNode.next;
            count++;
        }

        return currentNode;
    }

    remove(position) {
        let currentNode = this.head,
            length = this._length,
            count = 1,
            message = {failure: 'Failure: non-existent node in this list.'},
            beforeNodeToDelete = null,
            nodeToDelete = null,
            deletedNode = null;

        if (length === 0 || position < 1 || position > length) {
            throw new Error(message.failure);
        }

        if (position === 1) {
            deletedNode = this.head;
            this.head = currentNode.next;

            // if at list more than 1 node
            if (this.head) {
                this.head.previous = null;
                }
            // if at list only 1 node
            else {
                this.tail = null;
            }
        }
        // if position is last node
        else if (position === this._length) {
            deletedNode = this.tail;
            this.tail = this.tail.previous;
            this.tail.next = null;
        }
        // position isn't first or last node
        else {
            while (count < position) {
                currentNode = currentNode.next;
                count++;
            }

            beforeNodeToDelete = currentNode.previous;
            nodeToDelete = currentNode;
            afterNodeToDelete = currentNode.next;

            beforeNodeToDelete.next = afterNodeToDelete;
            afterNodeToDelete.previous = beforeNodeToDelete;
            deletedNode = nodeToDelete;
            nodeToDelete = null;
        }

        this._length--;

        return deletedNode;
    }
}

// ES5
function Node(value) {
    this.data = value;
    this.previous = null;
    this.next = null;
}

function DoublyList() {
    this._length = 0;
    this.head = null;
    this.tail = null;
}

DoublyList.prototype.add = function(value) {
    var node = new Node(value);

    if (this._length) {
        this.tail.next = node;
        node.previous = this.tail;
        this.tail = node;
    } else {
        this.head = node;
        this.tail = node;
    }

    this._length++;

    return node;
};

DoublyList.prototype.searchNodeAt = function(position) {
    var currentNode = this.head,
        length = this._length,
        count = 1,
        message = {failure: 'Failure: non-existent node in this list.'};

    // 1-ый случай: неверная позиция
    if (length === 0 || position < 1 || position > length) {
        throw new Error(message.failure);
    }

    // 2-ой случай: верная позиция
    while (count < position) {
        currentNode = currentNode.next;
        count++;
    }

    return currentNode;
};

DoublyList.prototype.remove = function(position) {
    var currentNode = this.head,
        length = this._length,
        count = 1,
        message = {failure: 'Failure: non-existent node in this list.'},
        beforeNodeToDelete = null,
        nodeToDelete = null,
        deletedNode = null;

    // 1-ый случай: неверная позиция
    if (length === 0 || position < 1 || position > length) {
        throw new Error(message.failure);
    }

    // 2-ой случай: первый узел удален
    if (position === 1) {
        this.head = currentNode.next;

        // 2-ой случай: существует второй узел
        if (!this.head) {
            this.head.previous = null;
        // 2-ой случай: второго узла не существует
        } else {
            this.tail = null;
        }

    // 3-ий случай: последний узел удален
    } else if (position === this._length) {
        this.tail = this.tail.previous;
        this.tail.next = null;
    // 4-ый случай: средний узел удален
    } else {
        while (count < position) {
            currentNode = currentNode.next;
            count++;
        }

        beforeNodeToDelete = currentNode.previous;
        nodeToDelete = currentNode;
        afterNodeToDelete = currentNode.next;

        beforeNodeToDelete.next = afterNodeToDelete;
        afterNodeToDelete.previous = beforeNodeToDelete;
        deletedNode = nodeToDelete;
        nodeToDelete = null;
    }

    this._length--;

    return message.success;
};


Дерево

------------------------------------------------------------------------------------------------------------------------

When a script uses document.write, that prevents it from being loaded asynchronously.
Many of 3rd-party scripts use it.

------------------------------------------------------------------------------------------------------------------------

Каррирование (Currying)
Especially useful with more advanced functional feature - combinatorics

Обычная функция и ее вызов
var greet = function(greeting, name) {
  console.log(greeting + ", " + name);
};
greet("Hello", "Heidi"); //"Hello, Heidi"


Каррированная функция и ее вызовы
Важен порядок аргументов!
!? http://ramdajs.com/

var greetCurried = function(greeting) {
  return function(name) {
    console.log(greeting + ", " + name);
  };
};
var greetHello = greetCurried("Hello");
greetHello("Heidi"); //"Hello, Heidi"
greetHello("Eddie"); //"Hello, Eddie"
greetCurried("Hi there")("Howard"); //"Hi there, Howard"

В общем случае, пример создания и вызова каррированной функции без ()()()...-hell
// not handle all of the edge cases, such as missing or optional parameters
var curryIt = function(uncurried) {
  var parameters = Array.prototype.slice.call(arguments, 1);
  return function() {
    return uncurried.apply(this, parameters.concat(
      Array.prototype.slice.call(arguments, 0)
    ));
  };
};

var greeter = function(greeting, separator, emphasis, name) {
  console.log(greeting + separator + name + emphasis);
};
var greetHello = curryIt(greeter, "Hello", ", ", ".");
greetHello("Heidi"); //"Hello, Heidi."
greetHello("Eddie"); //"Hello, Eddie."
var greetGoodbye = curryIt(greeter, "Goodbye", ", ");
greetGoodbye(".", "Joe"); //"Goodbye, Joe."
